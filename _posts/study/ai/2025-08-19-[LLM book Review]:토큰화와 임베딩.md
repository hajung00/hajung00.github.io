---
title: Large Language Model 책 리뷰 - 토큰화와 임베딩
author: cotes
date: 2025-08-18 01:33:00 +0800
categories: [Study, AI]
tags: [AI]
---

안녕하세요! 지난 글에서 LLM의 핵심인 트랜스포머 아키텍처에 대해 간략히 살펴봤는데요. 이번에는 LLM이 우리가 쓰는 자연어를 어떻게 학습하는지, LLM 학습의 기본이 되는 **토큰화**와 **임베딩**에 대한 내용을 정리하고, 책을 읽으며 들었던 몇 가지 의문점과 추가적으로 조사한 내용을 공유하려고 합니다.

<br/>

> ## 1. LLM 학습 과정: 텍스트를 숫자로
LLM은 원시 텍스트를 그대로 처리할 수 없기 때문에 학습에 앞서 텍스트 데이터를 숫자 벡터로 변환하는 과정이 필수적입니다. 이 과정은 크게 토큰화와 임베딩으로 나뉩니다.

### 1-1. 토큰화 

**토큰화**는 텍스트를 의미 있는 작은 단위인 **토큰**으로 분해하는 과정입니다. 이렇게 분해된 토큰은 각각 고유한 정수 ID로 변환됩니다.

<br/>

**토크나이저의 종류**

- **단순 토크나이저**: 공백이나 구두점을 기준으로 텍스트를 나눕니다. 간단하지만 "unforgettable"처럼 어휘에 없는 단어는 `<unk>`(unknown) 토큰으로 처리되어 정보 손실이 발생할 수 있습니다. 예를 들어, "unforgettable"이라는 단어가 어휘에 없으면 통째로 <unk>로 처리됩니다. 또한, <endoftxt> 와 같은 특수 토큰을 추가하여 여러 독립적인 텍스트 소스 사이의 경계를 명확히 구분해 LLM이 관련 없는 내용을 연결하지 않도록 돕습니다.

- **바이트 쌍 부호화(BPE)**: GPT 모델에서 사용하는 방식으로, 통계적인 방법을 활용해 자주 나타나는 문자 쌍을 병합해 어휘를 구축합니다. 이 방식은 모르는 단어가 나와도 더 작은 하위 단위로 쪼갤 수 있어 `<unk>` 토큰을 사용하지 않는다는 장점이 있습니다. 예를 들어, 'h'와 'e'가 자주 나타나면 'he'로 병합하는 식입니다. 이 방식은 어휘에 없는 단어를 더 작은 하위 단어 단위나 개별 문자로 분해하여 처리하므로, `<unk>` 토큰을 사용하지 않고도 어떤 단어든 처리할 수 있다는 큰 장점을 가집니다.

- **WordPiece**: 구글의 BERT 모델에서 사용되는 토크나이저입니다. BPE와 유사하게 통계적 방법을 사용하여 단어를 하위 단어 단위로 분할하지만, 병합 결정 방식이 다릅니다.

- **SentencePiece**: 구글에서 개발한 언어 독립적인 토크나이저로, 텍스트를 공백 문자를 포함한 원시 문자열로 처리하여 단어 경계가 모호한 언어에 특히 유용합니다.



이러한 특수 토큰들은 모델의 텍스트 이해도를 높이고 다양한 컨텍스트를 처리하는 데 도움을 줍니다. 예를 들어, `[BOS]` (beginning of sequence), `[EOS]` (end of sequence), `[PAD]` (padding) 토큰 등이 있습니다.

<br/>


### 1-2. 데이터 샘플링 

토큰화된 데이터를 바탕으로 LLM 학습에 사용할 입력-대상 쌍을 생성하는데, 이때 **슬라이딩 윈도우** 방식이 가장 널리 사용됩니다.

* **슬라이딩 윈도우**: 입력 토큰 시퀀스 $x$와 다음 단어가 한 칸씩 시프트된 대상 시퀀스 $y$를 생성합니다. 예를 들어, $x = [\text{토큰}1, \text{토큰}2, \text{토큰}3]$ 이면 $y = [\text{토큰}2, \text{토큰}3, \text{토큰}4]$가 되는 식이죠. 이 과정에서 **stride**(윈도우가 이동하는 칸 수)를 조절해 훈련 데이터의 오버랩 정도를 제어할 수 있습니다.

* **데이터 로더의 역할**: 효율적인 훈련을 위해 PyTorch의 DataLoader와 같은 도구를 사용해 대량의 데이터를 배치(batch) 단위로 처리합니다. 데이터 로더는 텍스트를 여러 청크(chunk)로 나누고, 각 청크는 입력과 대상 텐서로 변환됩니다.

* **stride의 중요성**: 이 과정에서 stride라는 매개변수가 중요한 역할을 합니다. stride는 슬라이딩 윈도우가 다음 청크를 생성하기 위해 이동하는 칸 수를 의미합니다.

    * **stride가 1인 경우**: 입력 청크가 한 칸씩 이동하므로 인접한 청크 간에 많은 **오버랩(overlap)**이 발생합니다. 이는 모델이 문맥을 더 풍부하게 학습하는 데 도움이 되지만, 과적합(overfitting)을 유발할 수 있습니다.

    * **stride가 max_length와 같은 경우**: 청크 간에 오버랩이 전혀 발생하지 않습니다. 이는 중복 학습을 피할 수 있어 효율적이며, 과적합 위험을 줄입니다.

<br/>

### 1-3. 임베딩 

**임베딩**은 토큰 ID를 실제 학습에 사용되는 숫자 벡터로 변환하는 과정입니다. LLM은 문장 내의 단어 순서나 위치 정보를 직접 파악하지 못하기 때문에, **위치 임베딩**을 추가하여 이 문제를 해결합니다.

<br/>

**절대적 위치 임베딩 (Absolute Positional Embedding)**: 시퀀스 내의 특정 위치와 직접적으로 연결된 임베딩입니다. 각 위치마다 고유한 임베딩이 토큰의 임베딩에 추가되어 정확한 위치를 명확하게 알려줍니다. GPT와 같은 모델은 이 방식을 사용하여 모델이 텍스트의 순서와 구조를 효과적으로 학습하도록 돕습니다.

- 주로 GPT와 같은 트랜스포머 기반의 대규모 언어 모델에서 사용됩니다.

- 명확한 위치 정보가 중요할 때: "나는 학교에 갔다."라는 문장에서 '나는'이 첫 번째, '학교에'가 두 번째 토큰이라는 절대적인 위치 정보를 모델에 명확하게 전달해야 할 때 사용됩니다.

- 구현의 단순성: 상대적 위치 임베딩에 비해 개념적으로 직관적이고 구현하기가 더 쉽습니다.

<br/>

**상대적 위치 임베딩 (Relative Positional Embedding)**: 토큰의 절대 위치보다는 토큰 간의 상대적인 위치 또는 거리를 강조합니다. 이 방식은 모델이 훈련 중에 보지 못했던 다양한 길이의 시퀀스를 더 효과적으로 처리하며, 긴 문장에서도 장거리 의존성을 포착하는 데 강점을 가집니다.

- RNN (순환 신경망) 계열이나 Transformer-XL과 같은 특정 트랜스포머 변형 모델에서 사용됩니다.
  
- 긴 문장 처리 및 일반화가 중요할 때: 모델이 훈련 데이터에서 보지 못했던 매우 긴 문장에서도 토큰 간의 거리를 효과적으로 학습해야 할 때 유용합니다.

- 문맥 의존성 파악: "나의 첫 번째 개는 매우 똑똑했다. 나의 두 번째 개는 매우 충성스러웠다."와 같은 문장에서 '첫 번째'와 '두 번째'가 '개'와 얼마나 떨어져 있는지와 같은 상대적 관계를 파악하는 데 강점을 가집니다.

- 순환적(Recurrent) 구조와 결합: 순환 신경망처럼 순서 정보를 내재적으로 처리하는 모델과 함께 사용될 때, 성능을 더욱 향상시킬 수 있습니다.

<br/>

요약하자면, 절대적 위치 임베딩은 토큰의 고정된 위치를 명확히 알려주어 문장 구조를 파악하는 데 유리하고, 상대적 위치 임베딩은 토큰 간의 거리를 학습하여 다양한 길이의 문맥에 대한 일반화 능력을 높이는 데 효과적입니다.

<br/>

---

<br/>


> ##  2. LLM마다 다른 토크나이저와 어휘 

기존의 Word2Vec 모델은 단어의 의미를 미리 학습해 임베딩 벡터를 고정했습니다. 하지만 LLM은 다릅니다. LLM은 별도의 Word2Vec 모델을 사용하지 않고, 학습 과정의 일부로 임베딩을 함께 최적화합니다. 임베딩 레이어는 처음에는 무작위 값으로 시작해 훈련 중에 역전파를 통해 가중치가 지속적으로 업데이트됩니다.

즉, LLM은 문맥을 통해 단어의 의미를 학습하며 임베딩 벡터 또한 지속적으로 개선해 나가는 것이죠.

<br/>

LLM의 인코더는 다음과 같은 구성 요소로 이루어져 있습니다.

* **토크나이저**: 텍스트를 토큰으로 분해하고 정수 ID를 부여합니다.

* **임베딩 레이어**: 토크나이저를 거쳐 나온 정수 ID를 고차원 벡터로 변환하는 역할을 합니다. 이 벡터는 단순한 숫자가 아니라, 단어의 의미와 문맥을 함축하고 있습니다.

    * 토큰 임베딩(Token Embedding): 토큰 ID를 벡터로 변환합니다. 비슷한 의미를 가진 토큰은 벡터 공간에서 서로 가깝게 위치하게 됩니다.

    * 위치 임베딩(Positional Encoding): 문장 내 토큰의 순서 정보를 벡터에 추가합니다. 트랜스포머 모델은 순서 정보를 자체적으로 파악할 수 없기 때문에, 이 위치 임베딩이 필수적입니다.

    * 분할 임베딩(Segment Embedding): 여러 문장이 입력될 때, 각 문장을 구분하는 정보를 벡터에 추가합니다.

* **트랜스포머 블록**: 핵심인 자기 주의(Self-Attention) 메커니즘을 통해 문장 내 모든 토큰 간의 관계를 파악하고 문맥적 이해를 심화시킵니다.

* **피드포워드 신경망**: 모델의 표현력을 높이고 복잡한 패턴을 학습하는 데 기여합니다.

<br/>

이러한 구성 요소들은 함께 작동하여 입력 텍스트를 문맥적으로 풍부한 벡터로 변환하고, 이를 기반으로 언어 생성, 분류, 번역 등 다양한 자연어 처리 작업을 수행하게 됩니다.



<br/>

---

<br/>



> ## 3. RAG와 단락 임베딩의 관계 



**RAG(Retrieval-Augmented Generation)**는 LLM의 지식 한계를 보완하기 위해 외부 문서에서 정보를 검색하여 답변을 생성하는 기술입니다. 이 과정에서 **단락 임베딩**과 **질문 임베딩**이 핵심적인 역할을 합니다.



* **단락 임베딩**: 외부 문서의 각 단락을 텍스트 임베딩 모델을 사용하여 하나의 벡터로 변환합니다.

* **질문 임베딩**: 사용자의 질문 또한 동일한 임베딩 모델을 사용하여 벡터로 변환됩니다.

* **유사성 검색**: 질문 벡터와 가장 유사한 단락 벡터를 벡터 데이터베이스에서 검색합니다.

* **정보 주입**: 검색된 단락을 LLM의 입력 프롬프트에 추가하여 모델이 더 정확하고 풍부한 답변을 생성하도록 돕습니다.



이때, 단락 임베딩에 사용되는 모델의 성능은 토크나이저에 의해 크게 좌우됩니다. 토크나이저는 단락의 의미를 얼마나 잘 보존하고 효율적으로 표현하는지 결정하기 때문입니다. 특히 BPE와 같은 하위 단어 토크나이저는 OOV(어휘 외) 문제 없이 다양한 단어를 처리할 수 있어, 검색 정확도를 높이는 데 기여합니다.

<br/>

RAG 시스템 구축 시 벡터 DB를 생성하는 데 사용되는 임베딩 모델 선정은 매우 중요합니다. 특정 도메인에 대한 전문성이 필요하거나, 데이터의 특성이 일반적이지 않거나, 검색 정확도를 최대로 끌어올려야 할 때 임베딩 모델을 해당 도메인 데이터로 파인튜닝하면 성능을 크게 향상시킬 수 있습니다.

<br/>

* **임베딩 모델 선정 시 고려사항**

    * **성능**: RAG 시스템의 핵심은 검색 정확도이므로, 텍스트의 의미적 유사성을 잘 포착하는 고성능 임베딩 모델을 선택해야 합니다.

    * **도메인 적합성**: 일반적인 텍스트로 학습된 모델보다 특정 도메인(예: 의료, 법률, 기술)에 특화된 모델을 사용하면 해당 분야의 전문 용어와 문맥을 더 잘 이해하여 검색 품질을 높일 수 있습니다.

    * **다중 언어 지원**: 여러 언어를 다루는 경우, 다양한 언어를 지원하는 다국어 임베딩 모델을 선택해야 합니다.

    * **효율성**: 모델의 크기와 추론 속도 또한 중요합니다. 대규모 데이터를 처리하거나 실시간으로 응답해야 하는 경우, 효율적인 모델을 선택해야 합니다.

<br/>


* **파인튜닝을 고려해야 할 상황**

    1. **특정 도메인에 대한 전문성이 필요할 때**: 일반적인 모델이 특정 산업이나 학문 분야의 미묘한 언어적 뉘앙스나 전문 용어를 완벽하게 이해하지 못할 수 있습니다.

    2. **검색 대상 데이터의 특성이 일반적이지 않을 때**: 내부 기업 문서, 고객 서비스 채팅 기록, 또는 온라인 커뮤니티 게시글처럼 특수한 언어 패턴을 포함할 때 파인튜닝이 필요합니다.

    3. **검색 정확도를 최대로 끌어올려야 할 때**: 높은 정확도가 필수적인 애플리케이션(예: 법률 문서 검색, 과학 연구 자료 검색)의 경우, 파인튜닝을 통해 최적화된 임베딩을 생성하여 극도로 높은 검색 정확도를 달성할 수 있습니다.



<br/>

---

<br/>




> ##  4. 트랜스포머 구조와 이미지 임베딩 



텍스트 임베딩은 단어, 문장 또는 문서를 벡터로 변환하는 과정입니다. LLM은 훈련의 일부로 임베딩 가중치를 최적화합니다. 이는 LLM이 문맥을 통해 단어의 의미를 학습하며 임베딩 벡터를 지속적으로 개선한다는 것을 의미합니다.



이미지 임베딩은 픽셀로 이루어진 이미지를 벡터로 변환하는 과정입니다. 이 과정은 트랜스포머 아키텍처의 발전과 함께 크게 변화했습니다.



* **트랜스포머 아키텍처 적용 전**: 기존에는 CNN(합성곱 신경망)을 사용하여 이미지의 특징을 추출하고 이를 벡터로 변환했습니다. CNN은 이미지의 지역적 특징을 잘 포착하지만, 전체적인 맥락을 이해하는 데는 한계가 있었습니다.

* **트랜스포머 아키텍처 적용 후**: **비전 트랜스포머(ViT)**는 이미지를 여러 개의 패치로 분할하고, 각 패치를 선형 임베딩으로 변환합니다. 텍스트의 단어처럼 이미지 패치에도 위치 임베딩을 추가하여 패치의 공간적 위치 정보를 트랜스포머 모델에 제공합니다. 트랜스포머의 핵심인 자기 주의(Self-Attention) 메커니즘을 통해 모델은 이미지 내의 모든 패치 간의 관계를 동시에 고려하여 전체적인 이미지 맥락을 이해할 수 있게 됩니다.
